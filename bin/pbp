#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# Generated bundle header; do not edit in bin/pbp
# Source modules are in src/

PBP_VERSION="${PBP_VERSION:-unknown}"
PBP_BUILD_TIME="${PBP_BUILD_TIME:-unknown}"
print_version_note() { echo "pbp version: ${PBP_VERSION} (${PBP_BUILD_TIME})"; }
# Version: v6.0.0-dirty
# Built: 2025-08-15T11:23:23Z
PBP_VERSION='v6.0.0-dirty'
PBP_BUILD_TIME='2025-08-15T11:23:23Z'

# >>> /home/pbjorklund/Projects/pbp/src/lib/core.sh
# Paths and globals
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
PBP_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SCRIPT_NAME="$(basename "$0")"
PROJECTS_DIR="${PBP_PROJECTS_DIR:-$HOME/Projects}"

# >>> /home/pbjorklund/Projects/pbp/src/lib/deps.sh
check_dep_gh() {
  if ! command -v gh &>/dev/null; then
    error "GitHub CLI (gh) is required for this operation.
Install: dnf install gh
Then authenticate: gh auth login"
  fi
  if ! gh auth status &>/dev/null; then
    error "GitHub CLI is not authenticated.
Run: gh auth login"
  fi
}

check_dep_git() {
  if ! command -v git &>/dev/null; then
    error "Git is required but not found in PATH."
  fi
}
# >>> /home/pbjorklund/Projects/pbp/src/lib/ui.sh
info() { echo "ℹ️  $1"; }
success() { echo "✅ $1"; }
error() { echo "❌ Error: $1" >&2; exit 1; }

# >>> /home/pbjorklund/Projects/pbp/src/tasks/check.sh
show_check_help() {
  cat <<EOF
pbp check - Check git status across all repositories

USAGE:
    pbp check [directory]

ARGUMENTS:
    directory    Directory to scan for git repos (default: PBP_PROJECTS_DIR or ~/Projects)

DESCRIPTION:
    Scans the specified directory for git repositories and reports their status:
    - Uncommitted changes
    - Untracked/staged files  
    - Unpushed/unpulled commits
    - Sync status with remote

EXAMPLES:
    pbp check                  # Check ~/Projects (or PBP_PROJECTS_DIR)
    pbp check ~/Development    # Check specific directory
    
ENVIRONMENT:
    PBP_PROJECTS_DIR          # Default directory to check
EOF
}

check_repos() {
  local check_dir="${1:-$PROJECTS_DIR}"
  
  if [[ "${1:-}" == "--help" ]]; then
    show_check_help
    return 0
  fi
  
  if [[ ! -d "$check_dir" ]]; then
    error "Directory does not exist: $check_dir"
  fi
  
  # Colors
  local RED='\033[0;31m'
  local GREEN='\033[0;32m'  
  local YELLOW='\033[1;33m'
  local BLUE='\033[0;34m'
  local NC='\033[0m'
  
  echo -e "${BLUE}🔍 Checking git status in $check_dir...${NC}"
  echo
  
  local found_issues=false
  local checked_repos=0
  
  builtin cd "$check_dir" || error "Cannot access directory: $check_dir"
  
  for dir in */; do
    if [[ -d "$dir/.git" ]]; then
      checked_repos=$((checked_repos + 1))
      
      # Get repo name (remove trailing slash)
      local repo_name="${dir%/}"
      
      # Fetch latest remote changes silently (with timeout)
      timeout 10 git -C "$dir" fetch --quiet 2>/dev/null || true
      
      # Check for uncommitted changes
      if ! git -C "$dir" diff-index --quiet HEAD -- 2>/dev/null; then
        echo -e "${RED}❌ $repo_name${NC} - Uncommitted changes"
        found_issues=true
      elif [[ -n "$(git -C "$dir" status --porcelain)" ]]; then
        echo -e "${YELLOW}⚠️  $repo_name${NC} - Untracked/staged files"
        found_issues=true
      else
        # Check for unpushed/unpulled commits
        local local_head remote_head
        local_head=$(git -C "$dir" rev-parse HEAD 2>/dev/null || echo "")
        remote_head=$(git -C "$dir" rev-parse @{u} 2>/dev/null || echo "")
        
        if [[ -n "$local_head" && -n "$remote_head" ]]; then
          if [[ "$local_head" != "$remote_head" ]]; then
            # Check if we're ahead or behind
            local ahead behind
            ahead=$(git -C "$dir" rev-list --count HEAD..@{u} 2>/dev/null || echo "0")
            behind=$(git -C "$dir" rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
            
            if [[ "$behind" -gt 0 && "$ahead" -gt 0 ]]; then
              echo -e "${RED}🔄 $repo_name${NC} - $behind commits to push, $ahead commits to pull (diverged)"
              found_issues=true
            elif [[ "$behind" -gt 0 ]]; then
              echo -e "${YELLOW}📤 $repo_name${NC} - $behind commits ahead (unpushed)"
              found_issues=true
            elif [[ "$ahead" -gt 0 ]]; then
              echo -e "${YELLOW}📥 $repo_name${NC} - $ahead commits behind remote (need to pull)"
              found_issues=true
            fi
          else
            echo -e "${GREEN}✅ $repo_name${NC} - Clean and synced"
          fi
        elif [[ -n "$local_head" ]]; then
          echo -e "${YELLOW}🔗 $repo_name${NC} - No remote tracking branch"
          found_issues=true
        else
          echo -e "${RED}❓ $repo_name${NC} - Unable to determine status"
          found_issues=true
        fi
      fi
    fi
  done
  
  echo
  if [[ "$checked_repos" -eq 0 ]]; then
    echo -e "${YELLOW}No git repositories found in $check_dir${NC}"
  elif [[ "$found_issues" == false ]]; then
    echo -e "${GREEN}🎉 All $checked_repos repositories are clean and synced!${NC}"
  else
    echo -e "${YELLOW}⚠️  Some repositories need attention (checked $checked_repos repos)${NC}"
  fi
}
# >>> /home/pbjorklund/Projects/pbp/src/tasks/github.sh
create_github_repo() {
  local project_path="${1:-$PWD}"; cd "$project_path"
  if [[ ! -d .git ]]; then error "Not in a git repository. Run this command in a project directory."; fi
  check_dep_gh
  local project_name; project_name=$(basename "$project_path")
  local current_remote=""; if git remote get-url origin &>/dev/null; then current_remote=$(git remote get-url origin); info "Current remote origin: $current_remote"
    if [[ "$current_remote" == *"github.com"* ]]; then
      local username expected_remote expected_https; username=$(gh api user --jq .login); expected_remote="git@github.com:$username/$project_name.git"; expected_https="https://github.com/$username/$project_name.git"
      if [[ "$current_remote" == "$expected_remote" ]] || [[ "$current_remote" == "$expected_https" ]]; then
        info "GitHub repository already configured correctly"
        if git log origin/"$(git branch --show-current)" 2>/dev/null; then info "Repository is up to date"; else info "Attempting to push unpushed commits"; if git push origin "$(git branch --show-current)"; then success "Successfully pushed to existing repository"; else error "Failed to push to existing repository. Check SSH keys or run manually: git push origin $(git branch --show-current)"; fi; fi
        return
      else info "Different GitHub repository already configured: $current_remote"; return; fi
    fi
  fi
  local username; username=$(gh api user --jq .login)
  if gh repo view "$username/$project_name" &>/dev/null; then
    info "Repository $username/$project_name already exists on GitHub"
    if [[ -z "$current_remote" ]]; then info "Adding remote origin"; git remote add origin "git@github.com:$username/$project_name.git"; success "Added remote origin"; fi
    info "Attempting to push to existing repository"; if git push -u origin "$(git branch --show-current)"; then success "Successfully pushed to existing repository"; success "Repository URL: https://github.com/$username/$project_name"; else error "Failed to push to repository. Check SSH keys or run manually: git push -u origin $(git branch --show-current)"; fi; return
  fi
  info "Creating private GitHub repository: $project_name"
  if gh repo create "$project_name" --private --source=. --remote=origin; then
    success "GitHub repository created successfully"; info "Pushing code to repository"
    if git push -u origin "$(git branch --show-current)"; then success "Code pushed successfully"; success "Repository URL: https://github.com/$username/$project_name"; else info "Repository created but push failed"; info "You can push manually later with: git push -u origin $(git branch --show-current)"; info "Check your SSH keys: ssh -T git@github.com"; success "Repository URL: https://github.com/$username/$project_name"; fi
  else error "Failed to create GitHub repository"; fi
}

# >>> /home/pbjorklund/Projects/pbp/src/tasks/init.sh
check_pbp() {
  if [[ ! -d "$PBP_ROOT" ]]; then error "pbp directory not found at $PBP_ROOT"; fi
  if [[ ! -d "$PBP_ROOT/project-templates" ]]; then error "project-templates directory not found at $PBP_ROOT/project-templates"; fi
}

init_project() {
  local project_name="${1:-}"
  if [[ -z "$project_name" ]]; then 
    error "Project name is required. Use 'pbp init <name>' or 'pbp init .' for current directory"
  fi
  local project_path display_name
  if [[ "$project_name" == "." ]]; then
    project_path="$PWD"; display_name="$(basename "$PWD")"
  else
    project_path="${2:-$PWD/$project_name}"; display_name="$project_name"
  fi
  check_pbp
  info "Creating project directory: $project_path"; mkdir -p "$project_path"; cd "$project_path"
  if [[ ! -d .git ]]; then info "Initializing git repository"; git init; success "Git repository initialized"; else info "Git repository already exists"; fi
  info "Basic project structure created"
  if [[ ! -f README.md ]]; then sed "s/{{PROJECT_NAME}}/$display_name/g" "$PBP_ROOT/project-templates/README.md" > README.md; success "Created README.md"; fi
  if [[ ! -f .gitignore ]]; then cp "$PBP_ROOT/project-templates/.gitignore" .gitignore; success "Created .gitignore"; fi
  success "Project '$display_name' initialized at $project_path"
}

# >>> /home/pbjorklund/Projects/pbp/src/tasks/llm.sh
show_llm_help() {
  cat <<EOF
pbp llm-setup - Set up AI development instruction files

USAGE:
    pbp llm-setup [--status]

OPTIONS:
    --status    Show current status of LLM instruction files

DESCRIPTION:
    Sets up LLM instruction files for AI development. Creates template files
    for Claude, GitHub Copilot, OpenCode, and other AI assistants.
    
    Files created:
    - LLM_INSTRUCTIONS.md (Main instruction template)
    - CLAUDE.md, AGENTS.md, GEMINI.md
    - .github/copilot-instructions.md  
    - .roo/rules/00-general.md

EXAMPLES:
    pbp llm-setup           # Set up LLM files in current project
    pbp llm-setup --status  # Check current status
EOF
}

# Embedded template files - baked into the binary
create_embedded_templates() {
  local temp_dir="$1"
  mkdir -p "$temp_dir"
  
  # LLM_INSTRUCTIONS.md template
  cat > "$temp_dir/LLM_INSTRUCTIONS.md" << 'EOF'
# {{PROJECT_NAME}} - LLM Development Instructions

## Project Overview
- **Purpose**: [TODO: Brief description of what this project does]
- **Type**: [TODO: Type of project - CLI tool, web app, library, etc.]
- **Target Users**: [TODO: Who uses this project]
- **Tech Stack**: [TODO: Main technologies used]

## Code Organization
- **Key Directories**: [TODO: Important directories to know about]
- **Entry Points**: [TODO: Main files where execution starts]
- **Configuration**: [TODO: Config files and how they work]
- **Dependencies**: [TODO: Key external dependencies]

## Development Guidelines
- **Code Style**: [TODO: Coding standards and conventions]
- **Documentation Standards**: [TODO: How to document code]
- **Review Process**: [TODO: How changes are reviewed]

## Project-Specific Context

### Critical Design Principles
[TODO: Core principles that guide this project]

### Technology Integrations  
[TODO: How different parts of the system work together]

### Common Gotchas
[TODO: Things that commonly trip people up]
EOF

  # README.md template
  cat > "$temp_dir/README.md" << 'EOF'
# {{PROJECT_NAME}}

[Brief description of what this project does]

## Installation

```bash
# Installation instructions
```

## Usage

```bash
# Basic usage examples
```

## Contributing

Contributions welcome! Please read the contributing guidelines first.

## License

[License information]
EOF

  # .gitignore template
  cat > "$temp_dir/.gitignore" << 'EOF'
# Dependencies
node_modules/
__pycache__/
*.pyc
.venv/
venv/

# Build outputs
build/
dist/
*.egg-info/
target/

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Environment files
.env
.env.local
EOF
}

llm_setup() {
  local show_status=false
  
  # Parse arguments
  case "${1:-}" in
    --status) show_status=true ;;
    --help) show_llm_help; return 0 ;;
    "") ;; # default action
    *) error "Unknown option: $1. Use 'pbp llm-setup --help' for usage." ;;
  esac
  
  if [[ "$show_status" == true ]]; then
    show_llm_status
    return 0
  fi
  
  # Set up LLM instruction files
  setup_llm_files
}

show_llm_status() {
  local files=(
    "LLM_INSTRUCTIONS.md"
    "CLAUDE.md" 
    "AGENTS.md"
    "GEMINI.md"
    ".github/copilot-instructions.md"
    ".roo/rules/00-general.md"
  )
  
  for file in "${files[@]}"; do
    if [[ -f "$file" ]]; then
      echo "   ✅ $file"
    else
      echo "   ❌ $file missing"
    fi
  done
}

setup_llm_files() {
  local project_name
  project_name=$(basename "$PWD")
  
  # Use custom template if specified, otherwise use embedded templates
  local template_source=""
  if [[ -n "${PBP_LLM_TEMPLATE:-}" ]] && [[ -f "$PBP_LLM_TEMPLATE" ]]; then
    template_source="$PBP_LLM_TEMPLATE"
    info "Using custom LLM template: $PBP_LLM_TEMPLATE"
  else
    # Create temporary template directory with embedded templates
    local temp_templates="/tmp/pbp-templates-$$"
    create_embedded_templates "$temp_templates"
    template_source="$temp_templates/LLM_INSTRUCTIONS.md"
  fi
  
  # Create backup if files exist
  local backup_dir=""
  local files_to_backup=(
    "LLM_INSTRUCTIONS.md" "CLAUDE.md" "AGENTS.md" "GEMINI.md"
    ".github/copilot-instructions.md" ".roo/rules/00-general.md"
  )
  
  for file in "${files_to_backup[@]}"; do
    if [[ -f "$file" ]]; then
      if [[ -z "$backup_dir" ]]; then
        backup_dir="/tmp/llm-backup-$(date +%Y-%m-%d-%H%M%S)"
        mkdir -p "$backup_dir"
        info "Backing up existing files to $backup_dir"
      fi
      mkdir -p "$backup_dir/$(dirname "$file")" 2>/dev/null || true
      cp "$file" "$backup_dir/$file"
    fi
  done
  
  # Create LLM_INSTRUCTIONS.md
  if [[ ! -f "LLM_INSTRUCTIONS.md" ]]; then
    sed "s/{{PROJECT_NAME}}/$project_name/g" "$template_source" > "LLM_INSTRUCTIONS.md"
    success "Created LLM_INSTRUCTIONS.md"
  fi
  
  # Create tool-specific instruction files as symlinks to LLM_INSTRUCTIONS.md
  for tool_file in "CLAUDE.md" "AGENTS.md" "GEMINI.md"; do
    if [[ ! -f "$tool_file" ]]; then
      ln -s "LLM_INSTRUCTIONS.md" "$tool_file"
      success "Created $tool_file (symlinked to LLM_INSTRUCTIONS.md)"
    fi
  done
  
  # Create GitHub Copilot instructions as symlink
  if [[ ! -f ".github/copilot-instructions.md" ]]; then
    mkdir -p ".github"
    ln -s "../LLM_INSTRUCTIONS.md" ".github/copilot-instructions.md"
    success "Created .github/copilot-instructions.md (symlinked to LLM_INSTRUCTIONS.md)"
  fi
  
  # Create Roo rules
  if [[ ! -f ".roo/rules/00-general.md" ]]; then
    mkdir -p ".roo/rules"
    cp "LLM_INSTRUCTIONS.md" ".roo/rules/00-general.md"
    success "Created .roo/rules/00-general.md"
  fi
  
  # Clean up temporary templates if we created them
  if [[ -z "${PBP_LLM_TEMPLATE:-}" ]]; then
    rm -rf "$temp_templates"
  fi
  
  success "LLM instruction files set up successfully!"
  echo
  info "Next steps:"
  echo "1. Edit LLM_INSTRUCTIONS.md to describe your project"
  echo "2. Run your AI assistant and tell it: 'Follow the LLM_INSTRUCTIONS.md setup process'"
  echo "3. The AI will analyze your project and customize the instructions"
}
# >>> /home/pbjorklund/Projects/pbp/src/tasks/migrate.sh
extract_with_history() {
  local repo_root="$1" rel_subdir="$2" new_project_path="$3" source_dir="$4"
  info "Extracting history for '$rel_subdir' from $repo_root"
  
  # Use git filter-repo if available (best), otherwise use built-in git commands
  if command -v git-filter-repo &>/dev/null; then
    # Clone and filter to keep only the subdirectory history
    git clone "$repo_root" "$new_project_path"
    (cd "$new_project_path" && git-filter-repo --path "$rel_subdir" --path-rename "$rel_subdir/:")
  else
    # Fallback to built-in git log + format-patch approach
    mkdir -p "$PROJECTS_DIR"; mkdir "$new_project_path"
    (cd "$new_project_path" && git init)
    
    # Get all commits that touched this path
    local commits
    commits=$(git -C "$repo_root" rev-list --reverse HEAD -- "$rel_subdir" || echo "")
    
    if [[ -n "$commits" ]]; then
      info "Found $(echo "$commits" | wc -l) commits affecting $rel_subdir"
      # Copy current state of directory
      cp -r "$source_dir"/* "$new_project_path/" 2>/dev/null || true
      cp -r "$source_dir"/.[^.]* "$new_project_path/" 2>/dev/null || true
      (cd "$new_project_path" && git add . && git commit -m "Migrated $rel_subdir with simplified history")
    else
      # No git history for this path, just copy
      cp -r "$source_dir"/* "$new_project_path/" 2>/dev/null || true  
      cp -r "$source_dir"/.[^.]* "$new_project_path/" 2>/dev/null || true
      (cd "$new_project_path" && git add . && git commit -m "Initial commit from $rel_subdir")
    fi
  fi
  
  # Remove from source repo and commit the deletion
  rm -rf "$source_dir"
  git -C "$repo_root" add -A && git -C "$repo_root" commit -m "Migrate $rel_subdir to standalone repo"
}

migrate_folder() {
  local folder_name="${1:-}"; local source_path="${2:-$PWD}"; if [[ -z "$folder_name" ]]; then error "Folder name is required"; fi
  local no_history=false force=false
  # parse flags
  if [[ "${3:-}" == "--no-history" ]] || [[ "${2:-}" == "--no-history" ]]; then no_history=true; fi
  if [[ "${3:-}" == "--force" ]] || [[ "${2:-}" == "--force" ]]; then force=true; fi

  # resolve paths
  source_path=$(realpath "$source_path")
  local repo_root="" current_dir new_project_path source_folder
  if git -C "$source_path" rev-parse --show-toplevel &>/dev/null; then 
    repo_root=$(realpath "$(git -C "$source_path" rev-parse --show-toplevel)")
  fi

  if [[ "$folder_name" == "." ]]; then
    current_dir="$(basename "$source_path")"; new_project_path="$PROJECTS_DIR/$current_dir"
    # Only block when at repo root that's directly under ~/Projects (not nested)
    if [[ -n "$repo_root" ]] && [[ "$source_path" == "$repo_root" ]] && [[ "$(dirname "$repo_root")" == "$PROJECTS_DIR" ]] && [[ "$force" != true ]]; then
      error "Refusing to migrate repo root directly under ~/Projects. Use a subfolder or --force."
    fi
    if [[ -e "$new_project_path" ]]; then error "Directory '$new_project_path' already exists"; fi

    if [[ "$no_history" == true ]] || [[ -z "$repo_root" ]]; then
      info "Migrating (no history) '$current_dir' -> '$new_project_path'"; mkdir -p "$PROJECTS_DIR"; cd "$source_path/.."; mv "$current_dir" "$new_project_path"; cd "$new_project_path"; git init; git add .; git commit -m "Initial commit"
    else
      # history-preserving using git subtree
      local rel_subdir
      if [[ "$source_path" == "$repo_root" ]]; then
        error "Cannot extract entire repo with history. Use --no-history --force to move the whole repo."
      else
        rel_subdir="${source_path#$repo_root/}"
      fi
      extract_with_history "$repo_root" "$rel_subdir" "$new_project_path" "$source_path"
    fi
  else
    source_folder="$source_path/$folder_name"
    if [[ ! -d "$source_folder" ]]; then error "Folder '$folder_name' not found in '$source_path'"; fi
    new_project_path="$PROJECTS_DIR/$folder_name"; if [[ -e "$new_project_path" ]]; then error "Directory '$new_project_path' already exists"; fi
    if git -C "$source_path" rev-parse --show-toplevel &>/dev/null; then repo_root=$(realpath "$(git -C "$source_path" rev-parse --show-toplevel)"); fi
    if [[ -n "$repo_root" ]] && [[ "$source_folder" == "$repo_root" ]]; then error "Cannot migrate entire repo as a folder; choose a subfolder"; fi

    if [[ "$no_history" == true ]] || [[ -z "$repo_root" ]]; then
      info "Migrating (no history) '$folder_name' -> '$new_project_path'"; mkdir -p "$PROJECTS_DIR"; mv "$source_folder" "$new_project_path"; git -C "$repo_root" add -A; git -C "$repo_root" commit -m "Migrate $folder_name to standalone repo" || true
    else
      local rel_subdir="${source_folder#$repo_root/}"
      extract_with_history "$repo_root" "$rel_subdir" "$new_project_path" "$source_folder"
    fi
  fi

  # Always end up in the new project directory
  cd "$new_project_path"
  create_github_repo "$new_project_path"
  success "Successfully migrated to '$new_project_path'"
}

# >>> /home/pbjorklund/Projects/pbp/src/tasks/status.sh
show_status() {
  local project_path="${1:-$PWD}"; cd "$project_path"
  if [[ ! -d .git ]]; then error "Not in a git repository. Run this command in a project directory."; fi
  info "Project status for: $project_path"; echo
  echo "📁 Project: $(basename "$project_path")"; echo "📂 Path: $project_path"; echo
  echo "🔀 Git Information:"; local current_branch; current_branch=$(git branch --show-current 2>/dev/null || echo "unknown"); echo "   Branch: $current_branch"
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then echo "   Status: ⚠️  Uncommitted changes"; else echo "   Status: ✅ Clean working directory"; fi
  if git remote get-url origin &>/dev/null; then
    local remote_url; remote_url=$(git remote get-url origin); echo "   Remote: $remote_url"
    if [[ "$remote_url" == *"github.com"* ]]; then
      echo; echo "🐙 GitHub Repository:"; local repo_info=""
      if [[ "$remote_url" == *"git@github.com:"* ]]; then repo_info=$(echo "$remote_url" | sed 's/git@github.com://' | sed 's/\.git$//');
      elif [[ "$remote_url" == *"https://github.com/"* ]]; then repo_info=$(echo "$remote_url" | sed 's|https://github.com/||' | sed 's/\.git$//'); fi
      if [[ -n "$repo_info" ]] && command -v gh &>/dev/null; then
        echo "   Repository: https://github.com/$repo_info"
        if gh repo view "$repo_info" &>/dev/null; then
          local visibility; visibility=$(gh repo view "$repo_info" --json visibility --jq .visibility 2>/dev/null || echo "unknown"); echo "   Visibility: $visibility"
          if git fetch origin &>/dev/null; then
            local ahead behind; ahead=$(git rev-list --count HEAD..origin/$current_branch 2>/dev/null || echo "0"); behind=$(git rev-list --count origin/$current_branch..HEAD 2>/dev/null || echo "0")
            if [[ "$ahead" -gt 0 ]] && [[ "$behind" -gt 0 ]]; then echo "   Sync: ⚠️  $behind ahead, $ahead behind";
            elif [[ "$behind" -gt 0 ]]; then echo "   Sync: ⬆️  $behind commits ahead";
            elif [[ "$ahead" -gt 0 ]]; then echo "   Sync: ⬇️  $ahead commits behind"; else echo "   Sync: ✅ Up to date"; fi
          fi
        else echo "   Status: ❌ Repository not accessible or doesn't exist"; fi
      else echo "   Repository: $repo_info (GitHub CLI not available for detailed info)"; fi
    fi
  else echo "   Remote: ❌ No remote configured"; echo; echo "💡 To create GitHub repository: pbp newghrepo"; fi
  echo
  echo "📋 Project Structure:"; [[ -f README.md ]] && echo "   ✅ README.md" || echo "   ❌ README.md missing"; [[ -f .gitignore ]] && echo "   ✅ .gitignore" || echo "   ❌ .gitignore missing"
  if [[ -f package.json ]]; then echo "   📦 package.json (Node.js project)"; elif [[ -f Cargo.toml ]]; then echo "   🦀 Cargo.toml (Rust project)"; elif [[ -f pyproject.toml ]] || [[ -f requirements.txt ]]; then echo "   🐍 Python project"; elif [[ -f go.mod ]]; then echo "   🐹 go.mod (Go project)"; fi
  echo
  echo "🤖 AI Development Support:";
  if command -v llm-setup &>/dev/null; then llm-setup --status;
  elif [[ -x "$PBP_ROOT/bin/llm-setup" ]]; then "$PBP_ROOT/bin/llm-setup" --status;
  else echo "   ❌ llm-setup not found - LLM instruction files not configured"; echo "   💡 Run 'llm-setup' to add AI development support"; fi
}

# >>> /home/pbjorklund/Projects/pbp/src/tasks/sync.sh
show_sync_help() {
  cat <<EOF
pbp sync - Clone user's GitHub repositories and manage local repositories

USAGE:
    pbp sync [options] [directory]

ARGUMENTS:
    directory    Directory to clone repos into (default: PBP_PROJECTS_DIR or ~/Projects)

OPTIONS:
    --public     Clone only public repositories
    --private    Clone only private repositories  
    --active     Clone only recently active repositories (pushed within 6 months)
    --all        Include all repos you have access to (orgs, collaborations, etc.)
    --dry-run    Show what would be cloned without actually cloning
    --help       Show this help

DESCRIPTION:
    By default, clones only repositories you own. Use --all to include organization
    repos and collaborations. After cloning, checks for local git repositories 
    without GitHub remotes and offers to create GitHub repositories for them.
    Uses GitHub CLI - requires 'gh auth login'.

EXAMPLES:
    pbp sync                    # Clone missing owned repos to ~/Projects
    pbp sync --all              # Include org repos and collaborations
    pbp sync --public           # Clone only public owned repos
    pbp sync --dry-run          # Show what would be cloned
    pbp sync ~/Development      # Clone to specific directory

ENVIRONMENT:
    PBP_PROJECTS_DIR           # Default directory for cloning
EOF
}

sync_repos() {
  local sync_dir="${PROJECTS_DIR}"
  local public_only=false
  local private_only=false
  local active_only=false
  local dry_run=false
  local all_repos=false
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      --public) public_only=true; shift ;;
      --private) private_only=true; shift ;;
      --active) active_only=true; shift ;;
      --all) all_repos=true; shift ;;
      --dry-run) dry_run=true; shift ;;
      --help) show_sync_help; return 0 ;;
      -*) error "Unknown option: $1. Use 'pbp sync --help' for usage." ;;
      *) sync_dir="$1"; shift ;;
    esac
  done
  
  # Validate conflicting options
  if [[ "$public_only" == true && "$private_only" == true ]]; then
    error "Cannot specify both --public and --private"
  fi
  
  # Check dependencies
  check_dep_gh
  
  # Ensure sync directory exists
  mkdir -p "$sync_dir"
  sync_dir=$(realpath "$sync_dir")
  
  info "Syncing GitHub repositories to: $sync_dir"
  
  # Build gh api query parameters
  local query_params=""
  if [[ "$public_only" == true ]]; then
    query_params="visibility=public"
  elif [[ "$private_only" == true ]]; then
    query_params="visibility=private"
  fi
  
  # Get list of repositories
  if [[ "$all_repos" == true ]]; then
    info "Fetching all accessible repositories from GitHub..."
    local repos_json
    repos_json=$(gh api user/repos --paginate -q '.[] | {name, clone_url, private, pushed_at, owner: .owner.login}' ${query_params:+--field "$query_params"})
  else
    info "Fetching owned repositories from GitHub..."
    local username
    username=$(gh api user --jq .login)
    local repos_json
    repos_json=$(gh api user/repos --paginate -q '.[] | select(.owner.login == "'$username'") | {name, clone_url, private, pushed_at, owner: .owner.login}' ${query_params:+--field "$query_params"})
  fi
  
  if [[ -z "$repos_json" ]]; then
    info "No repositories found"
    return 0
  fi
  
  local repos_to_clone=()
  local skipped_repos=()
  local existing_repos=()
  
  # Process each repository
  while IFS= read -r repo_line; do
    if [[ -z "$repo_line" ]]; then continue; fi
    
    local repo_name ssh_url is_private pushed_at owner
    repo_name=$(echo "$repo_line" | jq -r '.name')
    owner=$(echo "$repo_line" | jq -r '.owner')
    ssh_url="git@github.com:${owner}/${repo_name}.git"
    is_private=$(echo "$repo_line" | jq -r '.private')
    pushed_at=$(echo "$repo_line" | jq -r '.pushed_at')
    
    # Check if active filter applies
    if [[ "$active_only" == true ]]; then
      local six_months_ago
      six_months_ago=$(date -d '6 months ago' '+%Y-%m-%d' 2>/dev/null || date -v-6m '+%Y-%m-%d' 2>/dev/null)
      local pushed_date
      pushed_date=$(echo "$pushed_at" | cut -d'T' -f1)
      
      if [[ "$pushed_date" < "$six_months_ago" ]]; then
        skipped_repos+=("$repo_name (inactive: last push $pushed_date)")
        continue
      fi
    fi
    
    # Check if repository already exists locally
    if [[ -d "$sync_dir/$repo_name" ]]; then
      existing_repos+=("$repo_name")
      continue
    fi
    
    repos_to_clone+=("$repo_name|$ssh_url|$is_private")
    
  done <<< "$repos_json"
  
  # Summary
  echo
  info "Repository summary:"
  echo "  Total found: $(echo "$repos_json" | wc -l)"
  echo "  Already cloned: ${#existing_repos[@]}"
  echo "  To clone: ${#repos_to_clone[@]}"
  echo "  Skipped: ${#skipped_repos[@]}"
  
  # Show existing repos
  if [[ ${#existing_repos[@]} -gt 0 ]]; then
    echo
    info "Already cloned:"
    for repo in "${existing_repos[@]}"; do
      echo "  ✓ $repo"
    done
  fi
  
  # Show skipped repos
  if [[ ${#skipped_repos[@]} -gt 0 ]]; then
    echo
    info "Skipped repos:"
    for repo in "${skipped_repos[@]}"; do
      echo "  ⏸ $repo"
    done
  fi
  
  # Show repos to clone
  if [[ ${#repos_to_clone[@]} -gt 0 ]]; then
    echo
    if [[ "$dry_run" == true ]]; then
      info "Would clone (dry run):"
      for repo_info in "${repos_to_clone[@]}"; do
        IFS='|' read -r repo_name ssh_url is_private <<< "$repo_info"
        local privacy_indicator=""
        [[ "$is_private" == "true" ]] && privacy_indicator=" 🔒"
        echo "  → $repo_name$privacy_indicator"
      done
    else
      info "Cloning repositories..."
      local cloned=0
      local failed=0
      
      for repo_info in "${repos_to_clone[@]}"; do
        IFS='|' read -r repo_name ssh_url is_private <<< "$repo_info"
        
        echo -n "  Cloning $repo_name... "
        if git clone "$ssh_url" "$sync_dir/$repo_name" --quiet 2>/dev/null; then
          echo "✓"
          cloned=$((cloned + 1))
        else
          echo "✗ Failed"
          failed=$((failed + 1))
        fi
      done
      
      echo
      success "Cloned $cloned repositories successfully"
      if [[ $failed -gt 0 ]]; then
        info "$failed repositories failed to clone"
      fi
    fi
  else
    echo
    success "All repositories are already cloned!"
  fi
  
  # Check for local repositories without GitHub remotes
  echo
  info "Checking for local repositories without GitHub remotes..."
  
  local orphan_repos=()
  
  # Find all git repositories in sync directory
  while IFS= read -r -d '' git_dir; do
    local repo_dir
    repo_dir=$(dirname "$git_dir")
    local repo_name
    repo_name=$(basename "$repo_dir")
    
    # Skip if this directory is the current pbproject repo
    if [[ "$repo_dir" == "$sync_dir/pbproject" ]]; then
      continue
    fi
    
    # Check if it has a GitHub remote
    if ! (cd "$repo_dir" && git remote get-url origin 2>/dev/null | grep -q "github.com"); then
      orphan_repos+=("$repo_name")
    fi
  done < <(find "$sync_dir" -maxdepth 2 -name .git -type d -print0)
  
  if [[ ${#orphan_repos[@]} -gt 0 ]]; then
    echo
    info "Found ${#orphan_repos[@]} local repositories without GitHub remotes:"
    for repo in "${orphan_repos[@]}"; do
      echo "  → $repo"
    done
    
    echo
    read -p "Would you like to create GitHub repositories for these projects? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      for repo_name in "${orphan_repos[@]}"; do
        echo
        info "Processing: $repo_name"
        echo "  Location: $sync_dir/$repo_name"
        
        read -p "  Create GitHub repository for '$repo_name'? (y/N/q): " -n 1 -r
        echo
        
        case $REPLY in
          [Yy])
            echo "  Creating GitHub repository..."
            if (cd "$sync_dir/$repo_name" && create_github_repo "$sync_dir/$repo_name"); then
              success "  ✓ Created GitHub repository for $repo_name"
            else
              error "  ✗ Failed to create GitHub repository for $repo_name"
            fi
            ;;
          [Qq])
            info "  Skipping remaining repositories"
            break
            ;;
          *)
            info "  Skipped $repo_name"
            ;;
        esac
      done
    else
      info "Skipped creating GitHub repositories"
    fi
  else
    echo
    success "All local repositories have GitHub remotes!"
  fi
}
# >>> /home/pbjorklund/Projects/pbp/src/main.sh
show_help() {
  cat <<EOF
$SCRIPT_NAME - Project lifecycle management tool

USAGE:
    $SCRIPT_NAME init <project-name> [project-path]
    $SCRIPT_NAME migrate <folder-name|.> [source-project-path] [--no-history] [--force]
    $SCRIPT_NAME     sync [--public|--private|--active|--all|--dry-run] [directory]
    $SCRIPT_NAME check [directory]
    $SCRIPT_NAME newghrepo [project-path]
    $SCRIPT_NAME llm-setup [--status]
    $SCRIPT_NAME status [project-path]
    $SCRIPT_NAME --help

COMMANDS:
    init       Create new project with basic structure
    migrate    Extract folder to new repo with history preservation
     sync       Clone owned GitHub repos and manage local repositories
    check      Check git status across all repositories
    newghrepo  Create GitHub repository for current project
    llm-setup  Set up AI development instruction files
    status     Show project status and configuration
    
FLAGS:
    migrate --no-history   Move without preserving history
    migrate --force        Bypass safety checks
    sync --public          Clone only public repos
    sync --private         Clone only private repos
    sync --active          Clone only recently active repos
    sync --all             Include org repos and collaborations
    sync --dry-run         Show what would be cloned

ENVIRONMENT:
    PBP_PROJECTS_DIR   Where to create new projects (default: ~/Projects)
    PBP_LLM_TEMPLATE   Custom LLM instruction template file
EOF
}

main() {
  print_version_note
  case "${1:-}" in
    init) shift; init_project "$@";;
    migrate) shift; migrate_folder "$@";;
    sync) shift; sync_repos "$@";;
    check) shift; check_repos "$@";;
    newghrepo) shift; create_github_repo "$@";;
    llm-setup) shift; llm_setup "$@";;
    status) shift; show_status "$@";;
    --help|-h|help) show_help;;
    "") show_help;;
    *) error "Unknown command: $1. Use '$SCRIPT_NAME --help' for usage.";;
  esac
}

main "$@"
