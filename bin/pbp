#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# Generated bundle header; do not edit in bin/pbp
# Source modules are in src/

PBP_VERSION="${PBP_VERSION:-unknown}"
PBP_BUILD_TIME="${PBP_BUILD_TIME:-unknown}"
print_version_note() { echo "pbp version: ${PBP_VERSION} (${PBP_BUILD_TIME})"; }
# Version: v2.1.0-dirty
# Built: 2025-08-13T13:32:18Z
PBP_VERSION='v2.1.0-dirty'
PBP_BUILD_TIME='2025-08-13T13:32:18Z'

# >>> /home/pbjorklund/Projects/pbproject/src/lib/core.sh
# Paths and globals
SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
PBP_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SCRIPT_NAME="$(basename "$0")"
PROJECTS_DIR="${PBP_PROJECTS_DIR:-$HOME/Projects}"

# >>> /home/pbjorklund/Projects/pbproject/src/lib/deps.sh
check_dep_gh() {
  if ! command -v gh &>/dev/null; then
    error "GitHub CLI (gh) is required for this operation.
Install: dnf install gh
Then authenticate: gh auth login"
  fi
  if ! gh auth status &>/dev/null; then
    error "GitHub CLI is not authenticated.
Run: gh auth login"
  fi
}

check_dep_git() {
  if ! command -v git &>/dev/null; then
    error "Git is required but not found in PATH."
  fi
}
# >>> /home/pbjorklund/Projects/pbproject/src/lib/ui.sh
info() { echo "ℹ️  $1"; }
success() { echo "✅ $1"; }
error() { echo "❌ Error: $1" >&2; exit 1; }

# >>> /home/pbjorklund/Projects/pbproject/src/tasks/github.sh
create_github_repo() {
  local project_path="${1:-$PWD}"; cd "$project_path"
  if [[ ! -d .git ]]; then error "Not in a git repository. Run this command in a project directory."; fi
  check_dep_gh
  local project_name; project_name=$(basename "$project_path")
  local current_remote=""; if git remote get-url origin &>/dev/null; then current_remote=$(git remote get-url origin); info "Current remote origin: $current_remote"
    if [[ "$current_remote" == *"github.com"* ]]; then
      local username expected_remote expected_https; username=$(gh api user --jq .login); expected_remote="git@github.com:$username/$project_name.git"; expected_https="https://github.com/$username/$project_name.git"
      if [[ "$current_remote" == "$expected_remote" ]] || [[ "$current_remote" == "$expected_https" ]]; then
        info "GitHub repository already configured correctly"
        if git log origin/"$(git branch --show-current)" 2>/dev/null; then info "Repository is up to date"; else info "Attempting to push unpushed commits"; if git push origin "$(git branch --show-current)"; then success "Successfully pushed to existing repository"; else error "Failed to push to existing repository. Check SSH keys or run manually: git push origin $(git branch --show-current)"; fi; fi
        return
      else info "Different GitHub repository already configured: $current_remote"; return; fi
    fi
  fi
  local username; username=$(gh api user --jq .login)
  if gh repo view "$username/$project_name" &>/dev/null; then
    info "Repository $username/$project_name already exists on GitHub"
    if [[ -z "$current_remote" ]]; then info "Adding remote origin"; git remote add origin "git@github.com:$username/$project_name.git"; success "Added remote origin"; fi
    info "Attempting to push to existing repository"; if git push -u origin "$(git branch --show-current)"; then success "Successfully pushed to existing repository"; success "Repository URL: https://github.com/$username/$project_name"; else error "Failed to push to repository. Check SSH keys or run manually: git push -u origin $(git branch --show-current)"; fi; return
  fi
  info "Creating private GitHub repository: $project_name"
  if gh repo create "$project_name" --private --source=. --remote=origin; then
    success "GitHub repository created successfully"; info "Pushing code to repository"
    if git push -u origin "$(git branch --show-current)"; then success "Code pushed successfully"; success "Repository URL: https://github.com/$username/$project_name"; else info "Repository created but push failed"; info "You can push manually later with: git push -u origin $(git branch --show-current)"; info "Check your SSH keys: ssh -T git@github.com"; success "Repository URL: https://github.com/$username/$project_name"; fi
  else error "Failed to create GitHub repository"; fi
}

# >>> /home/pbjorklund/Projects/pbproject/src/tasks/init.sh
check_pbp() {
  if [[ ! -d "$PBP_ROOT" ]]; then error "pbp directory not found at $PBP_ROOT"; fi
  if [[ ! -f "$PBP_ROOT/bin/llm-setup" ]]; then error "llm-setup script not found at $PBP_ROOT/bin/llm-setup"; fi
  if [[ ! -d "$PBP_ROOT/project-templates" ]]; then error "project-templates directory not found at $PBP_ROOT/project-templates"; fi
}

init_project() {
  local project_name="${1:-}"
  if [[ -z "$project_name" ]]; then error "Project name is required"; fi
  local project_path display_name
  if [[ "$project_name" == "." ]]; then
    project_path="$PWD"; display_name="$(basename "$PWD")"
  else
    project_path="${2:-$PWD/$project_name}"; display_name="$project_name"
  fi
  check_pbp
  info "Creating project directory: $project_path"; mkdir -p "$project_path"; cd "$project_path"
  if [[ ! -d .git ]]; then info "Initializing git repository"; git init; success "Git repository initialized"; else info "Git repository already exists"; fi
  info "Basic project structure created"
  if [[ ! -f README.md ]]; then sed "s/{{PROJECT_NAME}}/$display_name/g" "$PBP_ROOT/project-templates/README.md" > README.md; success "Created README.md"; fi
  if [[ ! -f .gitignore ]]; then cp "$PBP_ROOT/project-templates/.gitignore" .gitignore; success "Created .gitignore"; fi
  success "Project '$display_name' initialized at $project_path"
}

# >>> /home/pbjorklund/Projects/pbproject/src/tasks/llm.sh
show_llm_help() {
  cat <<EOF
pbp llm-setup - Set up AI development instruction files

USAGE:
    pbp llm-setup [--status]

OPTIONS:
    --status    Show current status of LLM instruction files

DESCRIPTION:
    Sets up LLM instruction files for AI development. Creates template files
    for Claude, GitHub Copilot, OpenCode, and other AI assistants.
    
    Files created:
    - LLM_INSTRUCTIONS.md (Main instruction template)
    - CLAUDE.md, AGENTS.md, GEMINI.md
    - .github/copilot-instructions.md  
    - .roo/rules/00-general.md

EXAMPLES:
    pbp llm-setup           # Set up LLM files in current project
    pbp llm-setup --status  # Check current status
EOF
}

# Embedded template files - baked into the binary
create_embedded_templates() {
  local temp_dir="$1"
  mkdir -p "$temp_dir"
  
  # LLM_INSTRUCTIONS.md template
  cat > "$temp_dir/LLM_INSTRUCTIONS.md" << 'EOF'
# {{PROJECT_NAME}} - LLM Development Instructions

## Project Overview
- **Purpose**: [TODO: Brief description of what this project does]
- **Type**: [TODO: Type of project - CLI tool, web app, library, etc.]
- **Target Users**: [TODO: Who uses this project]
- **Tech Stack**: [TODO: Main technologies used]

## Code Organization
- **Key Directories**: [TODO: Important directories to know about]
- **Entry Points**: [TODO: Main files where execution starts]
- **Configuration**: [TODO: Config files and how they work]
- **Dependencies**: [TODO: Key external dependencies]

## Development Guidelines
- **Code Style**: [TODO: Coding standards and conventions]
- **Documentation Standards**: [TODO: How to document code]
- **Review Process**: [TODO: How changes are reviewed]

## Project-Specific Context

### Critical Design Principles
[TODO: Core principles that guide this project]

### Technology Integrations  
[TODO: How different parts of the system work together]

### Common Gotchas
[TODO: Things that commonly trip people up]
EOF

  # README.md template
  cat > "$temp_dir/README.md" << 'EOF'
# {{PROJECT_NAME}}

[Brief description of what this project does]

## Installation

```bash
# Installation instructions
```

## Usage

```bash
# Basic usage examples
```

## Contributing

Contributions welcome! Please read the contributing guidelines first.

## License

[License information]
EOF

  # .gitignore template
  cat > "$temp_dir/.gitignore" << 'EOF'
# Dependencies
node_modules/
__pycache__/
*.pyc
.venv/
venv/

# Build outputs
build/
dist/
*.egg-info/
target/

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Environment files
.env
.env.local
EOF
}

llm_setup() {
  local show_status=false
  
  # Parse arguments
  case "${1:-}" in
    --status) show_status=true ;;
    --help) show_llm_help; return 0 ;;
    "") ;; # default action
    *) error "Unknown option: $1. Use 'pbp llm-setup --help' for usage." ;;
  esac
  
  if [[ "$show_status" == true ]]; then
    show_llm_status
    return 0
  fi
  
  # Set up LLM instruction files
  setup_llm_files
}

show_llm_status() {
  local files=(
    "LLM_INSTRUCTIONS.md"
    "CLAUDE.md" 
    "AGENTS.md"
    "GEMINI.md"
    ".github/copilot-instructions.md"
    ".roo/rules/00-general.md"
  )
  
  for file in "${files[@]}"; do
    if [[ -f "$file" ]]; then
      echo "   ✅ $file"
    else
      echo "   ❌ $file missing"
    fi
  done
}

setup_llm_files() {
  local project_name
  project_name=$(basename "$PWD")
  
  # Use custom template if specified, otherwise use embedded templates
  local template_source=""
  if [[ -n "${PBP_LLM_TEMPLATE:-}" ]] && [[ -f "$PBP_LLM_TEMPLATE" ]]; then
    template_source="$PBP_LLM_TEMPLATE"
    info "Using custom LLM template: $PBP_LLM_TEMPLATE"
  else
    # Create temporary template directory with embedded templates
    local temp_templates="/tmp/pbp-templates-$$"
    create_embedded_templates "$temp_templates"
    template_source="$temp_templates/LLM_INSTRUCTIONS.md"
  fi
  
  # Create backup if files exist
  local backup_dir=""
  local files_to_backup=(
    "LLM_INSTRUCTIONS.md" "CLAUDE.md" "AGENTS.md" "GEMINI.md"
    ".github/copilot-instructions.md" ".roo/rules/00-general.md"
  )
  
  for file in "${files_to_backup[@]}"; do
    if [[ -f "$file" ]]; then
      if [[ -z "$backup_dir" ]]; then
        backup_dir="/tmp/llm-backup-$(date +%Y-%m-%d-%H%M%S)"
        mkdir -p "$backup_dir"
        info "Backing up existing files to $backup_dir"
      fi
      mkdir -p "$backup_dir/$(dirname "$file")" 2>/dev/null || true
      cp "$file" "$backup_dir/$file"
    fi
  done
  
  # Create LLM_INSTRUCTIONS.md
  if [[ ! -f "LLM_INSTRUCTIONS.md" ]]; then
    sed "s/{{PROJECT_NAME}}/$project_name/g" "$template_source" > "LLM_INSTRUCTIONS.md"
    success "Created LLM_INSTRUCTIONS.md"
  fi
  
  # Create tool-specific instruction files as independent copies
  for tool_file in "CLAUDE.md" "AGENTS.md" "GEMINI.md"; do
    if [[ ! -f "$tool_file" ]]; then
      cp "LLM_INSTRUCTIONS.md" "$tool_file"
      success "Created $tool_file"
    fi
  done
  
  # Create GitHub Copilot instructions
  if [[ ! -f ".github/copilot-instructions.md" ]]; then
    mkdir -p ".github"
    cp "LLM_INSTRUCTIONS.md" ".github/copilot-instructions.md"
    success "Created .github/copilot-instructions.md"
  fi
  
  # Create Roo rules
  if [[ ! -f ".roo/rules/00-general.md" ]]; then
    mkdir -p ".roo/rules"
    cp "LLM_INSTRUCTIONS.md" ".roo/rules/00-general.md"
    success "Created .roo/rules/00-general.md"
  fi
  
  # Clean up temporary templates if we created them
  if [[ -z "${PBP_LLM_TEMPLATE:-}" ]]; then
    rm -rf "$temp_templates"
  fi
  
  success "LLM instruction files set up successfully!"
  echo
  info "Next steps:"
  echo "1. Edit LLM_INSTRUCTIONS.md to describe your project"
  echo "2. Run your AI assistant and tell it: 'Follow the LLM_INSTRUCTIONS.md setup process'"
  echo "3. The AI will analyze your project and customize the instructions"
}
# >>> /home/pbjorklund/Projects/pbproject/src/tasks/migrate.sh
extract_with_history() {
  local repo_root="$1" rel_subdir="$2" new_project_path="$3" source_dir="$4"
  info "Extracting history for '$rel_subdir' from $repo_root"
  
  # Use git filter-repo if available (best), otherwise use built-in git commands
  if command -v git-filter-repo &>/dev/null; then
    # Clone and filter to keep only the subdirectory history
    git clone "$repo_root" "$new_project_path"
    (cd "$new_project_path" && git-filter-repo --path "$rel_subdir" --path-rename "$rel_subdir/:")
  else
    # Fallback to built-in git log + format-patch approach
    mkdir -p "$PROJECTS_DIR"; mkdir "$new_project_path"
    (cd "$new_project_path" && git init)
    
    # Get all commits that touched this path
    local commits
    commits=$(git -C "$repo_root" rev-list --reverse HEAD -- "$rel_subdir" || echo "")
    
    if [[ -n "$commits" ]]; then
      info "Found $(echo "$commits" | wc -l) commits affecting $rel_subdir"
      # Copy current state of directory
      cp -r "$source_dir"/* "$new_project_path/" 2>/dev/null || true
      cp -r "$source_dir"/.[^.]* "$new_project_path/" 2>/dev/null || true
      (cd "$new_project_path" && git add . && git commit -m "Migrated $rel_subdir with simplified history")
    else
      # No git history for this path, just copy
      cp -r "$source_dir"/* "$new_project_path/" 2>/dev/null || true  
      cp -r "$source_dir"/.[^.]* "$new_project_path/" 2>/dev/null || true
      (cd "$new_project_path" && git add . && git commit -m "Initial commit from $rel_subdir")
    fi
  fi
  
  # Remove from source repo and commit the deletion
  rm -rf "$source_dir"
  git -C "$repo_root" add -A && git -C "$repo_root" commit -m "Migrate $rel_subdir to standalone repo"
}

migrate_folder() {
  local folder_name="${1:-}"; local source_path="${2:-$PWD}"; if [[ -z "$folder_name" ]]; then error "Folder name is required"; fi
  local no_history=false force=false
  # parse flags
  if [[ "${3:-}" == "--no-history" ]] || [[ "${2:-}" == "--no-history" ]]; then no_history=true; fi
  if [[ "${3:-}" == "--force" ]] || [[ "${2:-}" == "--force" ]]; then force=true; fi

  # resolve paths
  source_path=$(realpath "$source_path")
  local repo_root="" current_dir new_project_path source_folder
  if git -C "$source_path" rev-parse --show-toplevel &>/dev/null; then 
    repo_root=$(realpath "$(git -C "$source_path" rev-parse --show-toplevel)")
  fi

  if [[ "$folder_name" == "." ]]; then
    current_dir="$(basename "$source_path")"; new_project_path="$PROJECTS_DIR/$current_dir"
    # Only block when at repo root that's directly under ~/Projects (not nested)
    if [[ -n "$repo_root" ]] && [[ "$source_path" == "$repo_root" ]] && [[ "$(dirname "$repo_root")" == "$PROJECTS_DIR" ]] && [[ "$force" != true ]]; then
      error "Refusing to migrate repo root directly under ~/Projects. Use a subfolder or --force."
    fi
    if [[ -e "$new_project_path" ]]; then error "Directory '$new_project_path' already exists"; fi

    if [[ "$no_history" == true ]] || [[ -z "$repo_root" ]]; then
      info "Migrating (no history) '$current_dir' -> '$new_project_path'"; mkdir -p "$PROJECTS_DIR"; cd "$source_path/.."; mv "$current_dir" "$new_project_path"; cd "$new_project_path"; git init; git add .; git commit -m "Initial commit"
    else
      # history-preserving using git subtree
      local rel_subdir
      if [[ "$source_path" == "$repo_root" ]]; then
        error "Cannot extract entire repo with history. Use --no-history --force to move the whole repo."
      else
        rel_subdir="${source_path#$repo_root/}"
      fi
      extract_with_history "$repo_root" "$rel_subdir" "$new_project_path" "$source_path"
    fi
  else
    source_folder="$source_path/$folder_name"
    if [[ ! -d "$source_folder" ]]; then error "Folder '$folder_name' not found in '$source_path'"; fi
    new_project_path="$PROJECTS_DIR/$folder_name"; if [[ -e "$new_project_path" ]]; then error "Directory '$new_project_path' already exists"; fi
    if git -C "$source_path" rev-parse --show-toplevel &>/dev/null; then repo_root=$(realpath "$(git -C "$source_path" rev-parse --show-toplevel)"); fi
    if [[ -n "$repo_root" ]] && [[ "$source_folder" == "$repo_root" ]]; then error "Cannot migrate entire repo as a folder; choose a subfolder"; fi

    if [[ "$no_history" == true ]] || [[ -z "$repo_root" ]]; then
      info "Migrating (no history) '$folder_name' -> '$new_project_path'"; mkdir -p "$PROJECTS_DIR"; mv "$source_folder" "$new_project_path"; git -C "$repo_root" add -A; git -C "$repo_root" commit -m "Migrate $folder_name to standalone repo" || true
    else
      local rel_subdir="${source_folder#$repo_root/}"
      extract_with_history "$repo_root" "$rel_subdir" "$new_project_path" "$source_folder"
    fi
  fi

  # Always end up in the new project directory
  cd "$new_project_path"
  create_github_repo "$new_project_path"
  success "Successfully migrated to '$new_project_path'"
}

# >>> /home/pbjorklund/Projects/pbproject/src/tasks/status.sh
show_status() {
  local project_path="${1:-$PWD}"; cd "$project_path"
  if [[ ! -d .git ]]; then error "Not in a git repository. Run this command in a project directory."; fi
  info "Project status for: $project_path"; echo
  echo "📁 Project: $(basename "$project_path")"; echo "📂 Path: $project_path"; echo
  echo "🔀 Git Information:"; local current_branch; current_branch=$(git branch --show-current 2>/dev/null || echo "unknown"); echo "   Branch: $current_branch"
  if ! git diff-index --quiet HEAD -- 2>/dev/null; then echo "   Status: ⚠️  Uncommitted changes"; else echo "   Status: ✅ Clean working directory"; fi
  if git remote get-url origin &>/dev/null; then
    local remote_url; remote_url=$(git remote get-url origin); echo "   Remote: $remote_url"
    if [[ "$remote_url" == *"github.com"* ]]; then
      echo; echo "🐙 GitHub Repository:"; local repo_info=""
      if [[ "$remote_url" == *"git@github.com:"* ]]; then repo_info=$(echo "$remote_url" | sed 's/git@github.com://' | sed 's/\.git$//');
      elif [[ "$remote_url" == *"https://github.com/"* ]]; then repo_info=$(echo "$remote_url" | sed 's|https://github.com/||' | sed 's/\.git$//'); fi
      if [[ -n "$repo_info" ]] && command -v gh &>/dev/null; then
        echo "   Repository: https://github.com/$repo_info"
        if gh repo view "$repo_info" &>/dev/null; then
          local visibility; visibility=$(gh repo view "$repo_info" --json visibility --jq .visibility 2>/dev/null || echo "unknown"); echo "   Visibility: $visibility"
          if git fetch origin &>/dev/null; then
            local ahead behind; ahead=$(git rev-list --count HEAD..origin/$current_branch 2>/dev/null || echo "0"); behind=$(git rev-list --count origin/$current_branch..HEAD 2>/dev/null || echo "0")
            if [[ "$ahead" -gt 0 ]] && [[ "$behind" -gt 0 ]]; then echo "   Sync: ⚠️  $behind ahead, $ahead behind";
            elif [[ "$behind" -gt 0 ]]; then echo "   Sync: ⬆️  $behind commits ahead";
            elif [[ "$ahead" -gt 0 ]]; then echo "   Sync: ⬇️  $ahead commits behind"; else echo "   Sync: ✅ Up to date"; fi
          fi
        else echo "   Status: ❌ Repository not accessible or doesn't exist"; fi
      else echo "   Repository: $repo_info (GitHub CLI not available for detailed info)"; fi
    fi
  else echo "   Remote: ❌ No remote configured"; echo; echo "💡 To create GitHub repository: pbp newghrepo"; fi
  echo
  echo "📋 Project Structure:"; [[ -f README.md ]] && echo "   ✅ README.md" || echo "   ❌ README.md missing"; [[ -f .gitignore ]] && echo "   ✅ .gitignore" || echo "   ❌ .gitignore missing"
  if [[ -f package.json ]]; then echo "   📦 package.json (Node.js project)"; elif [[ -f Cargo.toml ]]; then echo "   🦀 Cargo.toml (Rust project)"; elif [[ -f pyproject.toml ]] || [[ -f requirements.txt ]]; then echo "   🐍 Python project"; elif [[ -f go.mod ]]; then echo "   🐹 go.mod (Go project)"; fi
  echo
  echo "🤖 AI Development Support:";
  if command -v llm-setup &>/dev/null; then llm-setup --status;
  elif [[ -x "$PBP_ROOT/bin/llm-setup" ]]; then "$PBP_ROOT/bin/llm-setup" --status;
  else echo "   ❌ llm-setup not found - LLM instruction files not configured"; echo "   💡 Run 'llm-setup' to add AI development support"; fi
}

# >>> /home/pbjorklund/Projects/pbproject/src/main.sh
show_help() {
  cat <<EOF
$SCRIPT_NAME - Project lifecycle management tool

USAGE:
    $SCRIPT_NAME init <project-name> [project-path]
    $SCRIPT_NAME migrate <folder-name|.> [source-project-path] [--no-history] [--force]
    $SCRIPT_NAME newghrepo [project-path]
    $SCRIPT_NAME llm-setup [--status]
    $SCRIPT_NAME status [project-path]
    $SCRIPT_NAME --help

COMMANDS:
    init       Create new project with basic structure
    migrate    Extract folder to new repo with history preservation
    newghrepo  Create GitHub repository for current project
    llm-setup  Set up AI development instruction files
    status     Show project status and configuration
    
MIGRATE FLAGS:
    --no-history   Move without preserving history
    --force        Bypass safety checks

ENVIRONMENT:
    PBP_PROJECTS_DIR   Where to create new projects (default: ~/Projects)
EOF
}

main() {
  print_version_note
  case "${1:-}" in
    init) shift; init_project "$@";;
    migrate) shift; migrate_folder "$@";;
    newghrepo) shift; create_github_repo "$@";;
    llm-setup) shift; llm_setup "$@";;
    status) shift; show_status "$@";;
    --help|-h|help) show_help;;
    "") error "No command specified. Use '$SCRIPT_NAME --help' for usage.";;
    *) error "Unknown command: $1. Use '$SCRIPT_NAME --help' for usage.";;
  esac
}

main "$@"
